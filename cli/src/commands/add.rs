use std::{collections::HashSet, path::PathBuf};

use sqlx::{types::chrono::Utc, PgConnection};
use tokio::fs;

use crate::{
    models::{Payload, UpdatePath},
    util::{extension_versions, update_paths},
};

pub async fn add(
    payload: &Payload,
    output_path: &PathBuf,
    mut conn: PgConnection,
) -> anyhow::Result<()> {
    let existing_versions = extension_versions(&mut conn, &payload.metadata.extension_name).await?;
    let mut installed_extension_once = !existing_versions.is_empty();

    let timestamp = Utc::now().format("%Y%m%d%H%M%S");
    let mut migration_content = String::new();
    let mut versions_installed_now = HashSet::new();

    // Header with metadata
    migration_content.push_str(&format!(
        "-- Migration generated by dbdev add at {}\n",
        Utc::now().format("%Y-%m-%d %H:%M:%S")
    ));
    migration_content.push_str(&format!(
        "-- Extension: {}\n",
        payload.metadata.extension_name
    ));
    migration_content.push_str(&format!(
        "-- Default version: {}\n",
        payload.metadata.default_version
    ));
    if let Some(comment) = &payload.metadata.comment {
        migration_content.push_str(&format!("-- Comment: {}\n\n", comment));
    }

    // First installation requires different SQL than subsequent versions
    for install_file in &payload.install_files {
        if !existing_versions.contains(&install_file.version) {
            if installed_extension_once {
                // For subsequent versions
                migration_content
                    .push_str(&format!("-- Installing version {}\n", install_file.version));
                migration_content.push_str(&format!(
                "SELECT pgtle.install_extension_version_sql('{extension}', '{version}', $SQL${body}$SQL$);\n\n",
                extension = payload.metadata.extension_name,
                version = install_file.version,
                body = install_file.body
            ));
                versions_installed_now.insert(install_file.version.clone());
            } else {
                // For initial installation
                migration_content.push_str(&format!(
                    "-- Initial installation of version {}\n",
                    install_file.version
                ));

                migration_content.push_str(&format!(
                    "SELECT pgtle.install_extension('{extension}', '{version}', $COMMENT${comment}$COMMENT$,
                    $SQL${body}$SQL$, ARRAY[{requires}]::text[] );\n\n",
                    extension = payload.metadata.extension_name,
                    version = install_file.version,
                    comment = payload.metadata.comment.as_deref().unwrap_or(""),
                    body = install_file.body,
                    requires = payload.metadata.requires.join(",")));

                versions_installed_now.insert(install_file.version.clone());
                installed_extension_once = true;
            }
        }
    }

    // Add upgrade paths
    let existing_update_paths = update_paths(&mut conn, &payload.metadata.extension_name).await?;

    for upgrade_file in &payload.upgrade_files {
        if !existing_update_paths.contains(&UpdatePath {
            source: upgrade_file.from_version.clone(),
            target: upgrade_file.to_version.clone(),
        }) {
            migration_content.push_str(&format!(
                "SELECT pgtle.install_update_path('{extension}', '{from_version}', '{to_version}',
                $SQL${body}$SQL$);\n\n",
                extension = payload.metadata.extension_name,
                from_version = upgrade_file.from_version,
                to_version = upgrade_file.to_version,
                body = upgrade_file.body
            ));
        }
    }

    // Set default version
    migration_content.push_str(&format!(
        "-- Setting default version to {}\n",
        payload.metadata.default_version
    ));
    migration_content.push_str(&format!(
        "SELECT pgtle.set_default_version('{extension}', '{default_version}');\n",
        extension = payload.metadata.extension_name,
        default_version = payload.metadata.default_version
    ));

    // Write to file
    let filename = format!(
        "{}_{}_install.sql",
        timestamp, payload.metadata.extension_name
    );
    let file_path = output_path.join(filename);

    fs::write(&file_path, migration_content).await?;

    println!("Generated migration file at: {}", file_path.display());
    Ok(())
}
